
-- Enable HTTP extension
create extension if not exists http with schema extensions;
-- Enable pg_tle extension
create extension if not exists pg_tle;

-- Create profiles table
create table if not exists public.profiles (
  id uuid not null primary key,
  created_at timestamp with time zone not null default now(),
  display_name text,
  full_name text,
  email text,
  photo_url text,
  status text,
  bio text
);
comment on table public.profiles is 'Profile information for each user.';

-- Create friends table for mutual relationships
create table if not exists public.friends (
    user_id uuid not null references public.profiles(id) on delete cascade,
    friend_id uuid not null references public.profiles(id) on delete cascade,
    created_at timestamp with time zone not null default now(),
    primary key (user_id, friend_id)
);
comment on table public.friends is 'Stores mutual friendships between users.';

-- Create friend_requests table
create table if not exists public.friend_requests (
  id bigint generated by default as identity primary key,
  sender_id uuid not null references public.profiles(id) on delete cascade,
  receiver_id uuid not null references public.profiles(id) on delete cascade,
  status public.request_status not null default 'pending',
  created_at timestamp with time zone not null default now(),
  constraint unique_friend_request unique (sender_id, receiver_id)
);
comment on table public.friend_requests is 'Tracks pending, accepted, and declined friend requests.';

-- Create messages table for direct messages
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  sender_id uuid not null references public.profiles(id) on delete cascade,
  receiver_id uuid not null references public.profiles(id) on delete cascade,
  content text not null,
  created_at timestamp with time zone not null default now()
);
comment on table public.messages is 'Stores direct messages between users.';


-- Function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, email, display_name, full_name, photo_url, bio)
  values (
    new.id,
    new.email,
    new.raw_user_meta_data->>'display_name',
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    new.raw_user_meta_data->>'bio'
  );
  return new;
end;
$$;

-- Trigger to call handle_new_user on new user creation
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Policies for profiles table
alter table public.profiles enable row level security;
drop policy if exists "Users can see all profiles." on public.profiles;
create policy "Users can see all profiles." on public.profiles for select using (true);
drop policy if exists "Users can insert their own profile." on public.profiles;
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
drop policy if exists "Users can update their own profile." on public.profiles;
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id);


-- Policies for friends table
alter table public.friends enable row level security;
drop policy if exists "Users can view their own friendships." on public.friends;
create policy "Users can view their own friendships." on public.friends for select using (auth.uid() = user_id);
drop policy if exists "Users can create their own friendships." on public.friends;
create policy "Users can create their own friendships." on public.friends for insert with check (auth.uid() = user_id);
drop policy if exists "Users can delete their own friendships." on public.friends;
create policy "Users can delete their own friendships." on public.friends for delete using (auth.uid() = user_id);

-- Policies for friend_requests table
alter table public.friend_requests enable row level security;
drop policy if exists "Users can see their own friend requests." on public.friend_requests;
create policy "Users can see their own friend requests." on public.friend_requests for select using (auth.uid() = sender_id or auth.uid() = receiver_id);
drop policy if exists "Users can create friend requests." on public.friend_requests;
create policy "Users can create friend requests." on public.friend_requests for insert with check (auth.uid() = sender_id);
drop policy if exists "Receivers can update friend requests." on public.friend_requests;
create policy "Receivers can update friend requests." on public.friend_requests for update using (auth.uid() = receiver_id);

-- Policies for messages table
alter table public.messages enable row level security;
drop policy if exists "Users can view their own messages." on public.messages;
create policy "Users can view their own messages." on public.messages for select using (auth.uid() = sender_id or auth.uid() = receiver_id);
drop policy if exists "Users can send messages." on public.messages;
create policy "Users can send messages." on public.messages for insert with check (auth.uid() = sender_id);
drop policy if exists "Users can delete their own messages." on public.messages;
create policy "Users can delete their own messages." on public.messages for delete using (auth.uid() = sender_id);

-- This trigger is now managed by Supabase Studio, no need to define it here.
-- It ensures that when a user is deleted from auth.users, their corresponding profile is also deleted.
-- The cascade on foreign keys in other tables will handle the rest of the cleanup.

