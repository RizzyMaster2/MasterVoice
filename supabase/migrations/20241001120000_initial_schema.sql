
-- Profiles Table: Stores public-facing user information
CREATE TABLE public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    display_name text,
    full_name text,
    email text,
    photo_url text,
    status text,
    bio text
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Friends Table: Stores the many-to-many relationship between users
CREATE TABLE public.friends (
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    friend_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    PRIMARY KEY (user_id, friend_id)
);
ALTER TABLE public.friends ENABLE ROW LEVEL SECURITY;

-- Friend Requests Table: Manages pending, accepted, and declined friend requests
CREATE TABLE public.friend_requests (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    status text NOT NULL DEFAULT 'pending'::text,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT friend_requests_status_check CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'declined'::text]))),
    CONSTRAINT unique_friend_request UNIQUE (sender_id, receiver_id)
);
ALTER TABLE public.friend_requests ENABLE ROW LEVEL SECURITY;

-- Messages Table: Stores chat messages between two users
CREATE TABLE public.messages (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    receiver_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    content text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now()
);
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Function to create a public profile for a new user
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, email, display_name, full_name, photo_url)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'display_name',
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$;

-- Trigger to call the function when a new user signs up in auth.users
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to accept a friend request and create friendships
CREATE OR REPLACE FUNCTION public.accept_friend_request(request_id bigint, sender_id uuid, receiver_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if the caller is the receiver of the request
    IF auth.uid() != receiver_id THEN
        RAISE EXCEPTION 'Only the receiver can accept a friend request';
    END IF;

    -- Update the friend request status to 'accepted'
    UPDATE public.friend_requests
    SET status = 'accepted'
    WHERE id = request_id AND receiver_id = auth.uid() AND status = 'pending';

    -- If the update was successful, create the two-way friendship
    IF FOUND THEN
        INSERT INTO public.friends (user_id, friend_id)
        VALUES (sender_id, receiver_id), (receiver_id, sender_id)
        ON CONFLICT DO NOTHING; -- Avoid errors if friendship already exists
    END IF;
END;
$$;

-- RLS Policies for PROFILES
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can delete their own profile." ON public.profiles FOR DELETE USING (auth.uid() = id);

-- RLS Policies for FRIENDS
CREATE POLICY "Users can view their own friends." ON public.friends FOR SELECT USING (auth.uid() = user_id);
-- INSERT is handled by the accept_friend_request RPC function
-- DELETE is allowed for users to unfriend someone
CREATE POLICY "Users can delete their own friend records." ON public.friends FOR DELETE USING (auth.uid() = user_id OR auth.uid() = friend_id);

-- RLS Policies for FRIEND_REQUESTS
CREATE POLICY "Users can see their own friend requests (sent and received)." ON public.friend_requests FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send friend requests." ON public.friend_requests FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update their received friend requests (accept/decline)." ON public.friend_requests FOR UPDATE USING (auth.uid() = receiver_id);
-- No delete policy, requests are kept for history

-- RLS Policies for MESSAGES
CREATE POLICY "Users can view messages they sent or received." ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert their own messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can delete their own messages." ON public.messages FOR DELETE USING (auth.uid() = sender_id);

-- Configure Supabase Storage for user avatars
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('files', 'files', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif'])
ON CONFLICT (id) DO NOTHING;

CREATE POLICY "Avatar images are publicly accessible."
ON storage.objects FOR SELECT
USING ( bucket_id = 'files' );

CREATE POLICY "Anyone can upload an avatar."
ON storage.objects FOR INSERT
WITH CHECK ( bucket_id = 'files' );

CREATE POLICY "Users can update their own avatars."
ON storage.objects FOR UPDATE
USING ( auth.uid() = owner AND bucket_id = 'files' );
