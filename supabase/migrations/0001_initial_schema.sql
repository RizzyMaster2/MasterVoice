
-- Drop existing objects in a safe order
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.create_public_profile_for_user();
DROP FUNCTION IF EXISTS public.accept_friend_request(bigint, uuid, uuid);

DROP TABLE IF EXISTS public.messages CASCADE;
DROP TABLE IF EXISTS public.chat_participants CASCADE;
DROP TABLE IF EXISTS public.chats CASCADE;
DROP TABLE IF EXISTS public.friend_requests CASCADE;
DROP TABLE IF EXISTS public.friends CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;


-- Create profiles table
CREATE TABLE public.profiles (
  id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  display_name text NULL,
  full_name text NULL,
  email text NULL,
  photo_url text NULL,
  status text NULL,
  bio text NULL
);
-- Add comments to profiles table
COMMENT ON TABLE public.profiles IS 'Holds public-facing profile information for users.';

-- Create friends table
CREATE TABLE public.friends (
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  friend_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, friend_id),
  CONSTRAINT different_users CHECK (user_id <> friend_id)
);
-- Add comments to friends table
COMMENT ON TABLE public.friends IS 'Represents the friendship relationship between two users.';

-- Create friend_requests table
CREATE TABLE public.friend_requests (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status text NOT NULL DEFAULT 'pending'::text,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (sender_id, receiver_id),
  CONSTRAINT different_users_request CHECK (sender_id <> receiver_id)
);
-- Add comments to friend_requests table
COMMENT ON TABLE public.friend_requests IS 'Tracks pending, accepted, and declined friend requests.';

-- Create chats table
CREATE TABLE public.chats (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz NOT NULL DEFAULT now(),
  is_group_chat boolean NOT NULL DEFAULT false,
  group_name text NULL,
  group_photo_url text NULL
);
-- Add comments to chats table
COMMENT ON TABLE public.chats IS 'Represents a single chat, which can be a DM or a group chat.';

-- Create chat_participants table
CREATE TABLE public.chat_participants (
  chat_id bigint NOT NULL REFERENCES public.chats(id) ON DELETE CASCADE,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  joined_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (chat_id, user_id)
);
-- Add comments to chat_participants table
COMMENT ON TABLE public.chat_participants IS 'Associates users with the chats they are part of.';

-- Create messages table
CREATE TABLE public.messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  receiver_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);
-- Add comments to messages table
COMMENT ON TABLE public.messages IS 'Stores individual chat messages.';


-- Function to create a public profile for a new user
CREATE OR REPLACE FUNCTION public.create_public_profile_for_user()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name, email, photo_url, full_name, bio)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'display_name', NEW.email),
    NEW.email,
    NEW.raw_user_meta_data->>'avatar_url',
    COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.email),
    NEW.raw_user_meta_data->>'bio'
  );
  RETURN NEW;
END;
$$;
COMMENT ON FUNCTION public.create_public_profile_for_user() IS 'Creates a public profile for a new user upon signup.';

-- Trigger to execute the function after a new user is created
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.create_public_profile_for_user();
COMMENT ON TRIGGER on_auth_user_created ON auth.users IS 'Automatically creates a public profile when a new user signs up.';


-- Function to accept a friend request
CREATE OR REPLACE FUNCTION public.accept_friend_request(p_request_id bigint, p_sender_id uuid, p_receiver_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Update the friend request status to 'accepted'
    UPDATE public.friend_requests
    SET status = 'accepted'
    WHERE id = p_request_id AND receiver_id = p_receiver_id;

    -- Insert the two-way friendship
    INSERT INTO public.friends (user_id, friend_id)
    VALUES (p_receiver_id, p_sender_id), (p_sender_id, p_receiver_id)
    ON CONFLICT (user_id, friend_id) DO NOTHING;
    
    -- Delete the friend request now that it's been handled
    DELETE FROM public.friend_requests
    WHERE id = p_request_id;
END;
$$;
COMMENT ON FUNCTION public.accept_friend_request(bigint, uuid, uuid) IS 'Handles the logic for accepting a friend request, creating the friendship, and cleaning up the request.';

-- Enable Row Level Security (RLS) for all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.friends ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.friend_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Policies for profiles
CREATE POLICY "Public profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Users can delete their own profile" ON public.profiles FOR DELETE USING (auth.uid() = id);

-- Policies for friends
CREATE POLICY "Users can see their own friends." ON public.friends FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can add their own friends." ON public.friends FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can remove their own friends." ON public.friends FOR DELETE USING (auth.uid() = user_id);

-- Policies for friend_requests
CREATE POLICY "Users can see their own friend requests." ON public.friend_requests FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send friend requests." ON public.friend_requests FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update their received friend requests." ON public.friend_requests FOR UPDATE USING (auth.uid() = receiver_id);
CREATE POLICY "Users can delete their friend requests." ON public.friend_requests FOR DELETE USING (auth.uid() = sender_id OR auth.uid() = receiver_id);

-- Policies for messages
CREATE POLICY "Users can see messages they sent or received." ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can send messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can delete their own messages." ON public.messages FOR DELETE USING (auth.uid() = sender_id);

-- Policies for chats and chat_participants (more complex, starting simple)
CREATE POLICY "Users can see chats they are a part of." ON public.chats FOR SELECT USING (id IN (
  SELECT chat_id FROM public.chat_participants WHERE user_id = auth.uid()
));

CREATE POLICY "Users can see participants of chats they are in." ON public.chat_participants FOR SELECT USING (chat_id IN (
  SELECT chat_id FROM public.chat_participants WHERE user_id = auth.uid()
));
