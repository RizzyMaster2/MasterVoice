-- Drop existing policies on profiles to reset them
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can view all profiles." ON public.profiles;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.profiles;


-- create table public.profiles
create table if not exists public.profiles (
  id uuid not null references auth.users on delete cascade,
  created_at timestamp with time zone null default now(),
  display_name text null,
  full_name text null,
  email text null,
  photo_url text null,
  status text null default 'offline'::text,
  bio text null,
  primary key (id)
);
alter table public.profiles enable row level security;

-- Policies for profiles
create policy "Users can view all profiles." on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id) with check (auth.uid() = id);

-- create table public.chats
create table if not exists public.chats (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  user1_id uuid not null,
  user2_id uuid not null,
  last_message_id bigint null,
  primary key (id),
  foreign key (user1_id) references auth.users (id),
  foreign key (user2_id) references auth.users (id)
);
alter table public.chats enable row level security;
create policy "Users can see and create their own chats." on public.chats for all using ((auth.uid() = user1_id) or (auth.uid() = user2_id));

-- create table public.messages
create table if not exists public.messages (
  id bigint generated by default as identity,
  created_at timestamp with time zone not null default now(),
  sender_id uuid not null,
  receiver_id uuid not null,
  content text null,
  chat_id bigint null,
  primary key (id),
  foreign key (sender_id) references auth.users (id),
  foreign key (receiver_id) references auth.users (id),
  foreign key (chat_id) references public.chats (id)
);
alter table public.messages enable row level security;
create policy "Users can send and receive their own messages." on public.messages for all using ((auth.uid() = sender_id) or (auth.uid() = receiver_id));

-- create table public.friends
create table if not exists public.friends (
  user_id uuid not null,
  friend_id uuid not null,
  created_at timestamp with time zone null default now(),
  primary key (user_id, friend_id),
  foreign key (user_id) references auth.users (id),
  foreign key (friend_id) references auth.users (id)
);
alter table public.friends enable row level security;
create policy "Users can view their own friends." on public.friends for select using (auth.uid() = user_id);
create policy "Users can manage their own friendships." on public.friends for insert with check (auth.uid() = user_id);
create policy "Users can delete their own friendships." on public.friends for delete using (auth.uid() = user_id);


-- create table public.friend_requests
create table if not exists public.friend_requests (
  id bigint generated by default as identity primary key,
  sender_id uuid not null references auth.users(id),
  receiver_id uuid not null references auth.users(id),
  status text not null default 'pending' check (status in ('pending', 'accepted', 'declined')),
  created_at timestamp with time zone not null default now(),
  unique(sender_id, receiver_id)
);
alter table public.friend_requests enable row level security;
create policy "Users can see and manage their own friend requests." on public.friend_requests for all using (auth.uid() = sender_id or auth.uid() = receiver_id);


-- Set up realtime
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table public.messages;
alter publication supabase_realtime add table public.profiles;
alter publication supabase_realtime add table public.friends;
alter publication supabase_realtime add table public.friend_requests;


-- handle new user function
drop trigger if exists on_auth_user_created on auth.users;
drop function if exists public.handle_new_user;

create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, display_name, full_name, email, photo_url)
  values (
    new.id,
    new.raw_user_meta_data->>'display_name',
    new.raw_user_meta_data->>'full_name',
    new.email,
    new.raw_user_meta_data->>'avatar_url'
  );
  return new;
end;
$$;

-- trigger for new user
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create storage bucket for files
insert into storage.buckets (id, name, public)
values ('files', 'files', true)
on conflict (id) do nothing;

create policy "User can upload an avatar." on storage.objects for insert with check (bucket_id = 'files' and auth.uid() = (storage.foldername(name))[1]);
create policy "User can update their own avatar." on storage.objects for update with check (bucket_id = 'files' and auth.uid() = (storage.foldername(name))[1]);
create policy "Anyone can see the avatars." on storage.objects for select with check (bucket_id = 'files');
