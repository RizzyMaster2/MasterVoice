
-- Drop dependent objects before modifying the function
drop trigger if exists on_auth_user_created on auth.users;

-- Function to create a profile for a new user
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, full_name, display_name, email, bio)
  values (
    new.id,
    new.raw_user_meta_data ->> 'full_name',
    new.raw_user_meta_data ->> 'display_name',
    new.email,
    new.raw_user_meta_data ->> 'bio'
  );
  return new;
end;
$$;

-- Recreate the trigger
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Drop old tables and types safely
drop table if exists public.friends;
drop table if exists public.messages;
drop table if exists public.friend_requests;

-- Create public.friend_requests table
create table if not exists public.friend_requests (
    id bigint generated by default as identity primary key,
    sender_id uuid not null references auth.users(id) on delete cascade,
    receiver_id uuid not null references auth.users(id) on delete cascade,
    status text not null default 'pending', -- pending, accepted, declined
    created_at timestamp with time zone not null default now(),
    unique(sender_id, receiver_id)
);
alter table public.friend_requests enable row level security;


-- Create public.friends table
create table if not exists public.friends (
    user_id uuid not null references auth.users(id) on delete cascade,
    friend_id uuid not null references auth.users(id) on delete cascade,
    created_at timestamp with time zone not null default now(),
    primary key (user_id, friend_id)
);
alter table public.friends enable row level security;

-- Create public.messages table
create table if not exists public.messages (
    id bigint generated by default as identity primary key,
    sender_id uuid not null references public.profiles(id) on delete cascade,
    receiver_id uuid not null references public.profiles(id) on delete cascade,
    content text not null,
    created_at timestamp with time zone not null default now()
);
alter table public.messages enable row level security;


-- Add missing columns to profiles table if they don't exist
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'full_name') THEN
    ALTER TABLE public.profiles ADD COLUMN full_name text;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'display_name') THEN
    ALTER TABLE public.profiles ADD COLUMN display_name text;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'photo_url') THEN
    ALTER TABLE public.profiles ADD COLUMN photo_url text;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'status') THEN
    ALTER TABLE public.profiles ADD COLUMN status text;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'bio') THEN
    ALTER TABLE public.profiles ADD COLUMN bio text;
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_attribute WHERE attrelid = 'public.profiles'::regclass AND attname = 'email') THEN
    ALTER TABLE public.profiles ADD COLUMN email text;
  END IF;
END;
$$;


-- RLS Policies
drop policy if exists "Public profiles are viewable by everyone." on public.profiles;
create policy "Public profiles are viewable by everyone."
  on public.profiles for select
  using ( true );

drop policy if exists "Users can insert their own profile." on public.profiles;
create policy "Users can insert their own profile."
  on public.profiles for insert
  with check ( auth.uid() = id );

drop policy if exists "Users can update their own profile." on public.profiles;
create policy "Users can update their own profile."
  on public.profiles for update
  using (auth.uid() = id)
  with check ( auth.uid() = id );

-- Policies for friends table
drop policy if exists "Users can view their own friends" on public.friends;
create policy "Users can view their own friends"
  on public.friends for select
  using ( auth.uid() = user_id );

drop policy if exists "Users can add friends" on public.friends;
create policy "Users can add friends"
  on public.friends for insert
  with check ( auth.uid() = user_id );

drop policy if exists "Users can delete their own friendships" on public.friends;
create policy "Users can delete their own friendships"
    on public.friends for delete
    using (auth.uid() = user_id or auth.uid() = friend_id);


-- Policies for messages table
drop policy if exists "Users can view messages they sent or received" on public.messages;
create policy "Users can view messages they sent or received"
  on public.messages for select
  using ( auth.uid() = sender_id or auth.uid() = receiver_id );

drop policy if exists "Users can insert their own messages" on public.messages;
create policy "Users can insert their own messages"
  on public.messages for insert
  with check ( auth.uid() = sender_id );

drop policy if exists "Users can delete their own messages" on public.messages;
create policy "Users can delete their own messages"
    on public.messages for delete
    using (auth.uid() = sender_id);

-- Policies for friend_requests table
drop policy if exists "Users can create friend requests" on public.friend_requests;
create policy "Users can create friend requests"
    on public.friend_requests for insert
    with check (auth.uid() = sender_id);

drop policy if exists "Users can see their own friend requests" on public.friend_requests;
create policy "Users can see their own friend requests"
    on public.friend_requests for select
    using (auth.uid() = sender_id or auth.uid() = receiver_id);

drop policy if exists "Users can update their own friend requests" on public.friend_requests;
create policy "Users can update their own friend requests"
    on public.friend_requests for update
    using (auth.uid() = receiver_id);

