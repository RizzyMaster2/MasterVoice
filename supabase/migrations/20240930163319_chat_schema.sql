-- Drop the existing trigger first
drop trigger if exists on_auth_user_created on auth.users;

-- Create a function to handle new user creation
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, photo_url, display_name, email)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'avatar_url',
    new.raw_user_meta_data->>'display_name',
    new.email
  );
  return new;
end;
$$ language plpgsql security definer;

-- Re-create the trigger to call the function on new user creation
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create the profiles table
create table if not exists public.profiles (
  id uuid not null primary key references auth.users on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  display_name text,
  full_name text,
  photo_url text,
  status text default 'offline'::text,
  bio text,
  email text
);
comment on table public.profiles is 'Public user profiles.';

-- Create the chats table
create table if not exists public.chats (
  id bigint primary key generated by default as identity,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  is_group_chat boolean default false
);
comment on table public.chats is 'Chat sessions.';

-- Create the chat_participants table
create table if not exists public.chat_participants (
  chat_id bigint not null references public.chats on delete cascade,
  user_id uuid not null references public.profiles on delete cascade,
  created_at timestamp with time zone default timezone('utc_inner'::text, now()) not null,
  primary key (chat_id, user_id)
);
comment on table public.chat_participants is 'Users participating in a chat.';

-- Create the messages table
create table if not exists public.messages (
  id bigint primary key generated by default as identity,
  sender_id uuid not null references public.profiles on delete cascade,
  receiver_id uuid not null references public.profiles on delete cascade,
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  chat_id bigint null references public.chats on delete cascade
);
comment on table public.messages is 'Chat messages.';

-- Create the friends table
create table if not exists public.friends (
  user_id uuid not null references public.profiles on delete cascade,
  friend_id uuid not null references public.profiles on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (user_id, friend_id)
);
comment on table public.friends is 'Friend relationships.';

-- Create friend_requests table
create table if not exists public.friend_requests (
  id bigint primary key generated by default as identity,
  sender_id uuid not null references public.profiles(id) on delete cascade,
  receiver_id uuid not null references public.profiles(id) on delete cascade,
  status text not null default 'pending' check (status in ('pending', 'accepted', 'declined')),
  created_at timestamp with time zone not null default timezone('utc'::text, now()),
  constraint unique_friend_request unique (sender_id, receiver_id)
);
comment on table public.friend_requests is 'Manages friend requests between users.';

-- Set up Row Level Security (RLS)
alter table public.profiles enable row level security;
alter table public.chats enable row level security;
alter table public.chat_participants enable row level security;
alter table public.messages enable row level security;
alter table public.friends enable row level security;
alter table public.friend_requests enable row level security;


-- Policies for profiles
create policy "Users can see all profiles." on public.profiles for select using (true);
create policy "Users can insert their own profile." on public.profiles for insert with check (auth.uid() = id);
create policy "Users can update their own profile." on public.profiles for update using (auth.uid() = id) with check (auth.uid() = id);
create policy "Users can delete their own profile." on public.profiles for delete using (auth.uid() = id);

-- Policies for chats, messages, friends
create policy "Users can view their own chats." on public.chats for select using (
  exists (
    select 1 from public.chat_participants where chat_id = id and user_id = auth.uid()
  )
);
create policy "Users can CRUD messages in their chats." on public.messages for all using (
  (sender_id = auth.uid()) or
  (receiver_id = auth.uid())
);
create policy "Users can manage their own friendships." on public.friends for all using (user_id = auth.uid());

-- Policies for friend_requests
create policy "Users can see their own friend requests." on public.friend_requests for select
  using(sender_id = auth.uid() or receiver_id = auth.uid());

create policy "Users can send friend requests." on public.friend_requests for insert
  with check(sender_id = auth.uid());

create policy "Users can update their received friend requests." on public.friend_requests for update
  using(receiver_id = auth.uid());
  
-- Create storage bucket for files
insert into storage.buckets (id, name, public)
values ('files', 'files', true)
on conflict (id) do nothing;

create policy "Users can view files." on storage.objects for select
  using ( bucket_id = 'files' );

create policy "Users can upload files to their own folder." on storage.objects for insert
  with check ( bucket_id = 'files' and auth.uid()::text = (storage.foldername(name))[1] );

create policy "Users can update files in their own folder." on storage.objects for update
  using ( bucket_id = 'files' and auth.uid()::text = (storage.foldername(name))[1] );

create policy "Users can delete files from their own folder." on storage.objects for delete
  using ( bucket_id = 'files' and auth.uid()::text = (storage.foldername(name))[1] );
