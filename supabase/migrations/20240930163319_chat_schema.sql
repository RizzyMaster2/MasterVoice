-- Drop existing policies on profiles to ensure a clean slate
DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
DROP POLICY IF EXISTS "Users can view all profiles." ON public.profiles;
DROP POLICY IF EXISTS "Allow public read-only access to everyone" ON public.profiles;


-- Drop dependent trigger before modifying the function
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;

-- Create or replace the function to handle new user creation
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, display_name, photo_url, email)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'display_name',
    new.raw_user_meta_data->>'avatar_url',
    new.email
  );
  return new;
END;
$$;

-- Re-create the trigger to call the function on new user sign-up
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Create table for public profiles
CREATE TABLE IF NOT EXISTS public.profiles (
  id uuid references auth.users not null primary key,
  created_at timestamp with time zone not null default now(),
  display_name text,
  full_name text,
  photo_url text,
  email text,
  status text,
  bio text
);
COMMENT ON TABLE public.profiles IS 'Public user profiles, available to all authenticated users.';

-- Create table for one-on-one chats (deprecated, use messages table)
CREATE TABLE IF NOT EXISTS public.chats (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone not null default now(),
  participant1_id uuid references public.profiles not null,
  participant2_id uuid references public.profiles not null
);
COMMENT ON TABLE public.chats IS 'Represents a chat session between two users.';

-- Create table for messages
CREATE TABLE IF NOT EXISTS public.messages (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone not null default now(),
  sender_id uuid references public.profiles not null,
  receiver_id uuid references public.profiles not null,
  content text
);
COMMENT ON TABLE public.messages IS 'Stores individual chat messages between users.';

-- Create table for friend relationships
CREATE TABLE IF NOT EXISTS public.friends (
  user_id uuid references auth.users not null,
  friend_id uuid references auth.users not null,
  created_at timestamp with time zone not null default now(),
  primary key (user_id, friend_id)
);
COMMENT ON TABLE public.friends IS 'Stores friendship relationships between users.';

-- Create table for friend requests
CREATE TABLE IF NOT EXISTS public.friend_requests (
  id bigint generated by default as identity primary key,
  sender_id uuid references auth.users not null,
  receiver_id uuid references auth.users not null,
  status text check (status in ('pending', 'accepted', 'declined')) not null default 'pending',
  created_at timestamp with time zone not null default now(),
  unique(sender_id, receiver_id)
);
COMMENT ON TABLE public.friend_requests IS 'Tracks pending, accepted, and declined friend requests.';

-- Create storage bucket for files
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('files', 'files', true, 5242880, '{"image/*"}' ) ON CONFLICT (id) DO NOTHING;


-- Set up Row Level Security (RLS)

-- Profiles
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view all profiles." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Chats (deprecated but policy included for completeness)
ALTER TABLE public.chats ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own chats." ON public.chats FOR SELECT USING (auth.uid() = participant1_id OR auth.uid() = participant2_id);

-- Messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view messages they sent or received." ON public.messages FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert their own messages." ON public.messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can delete their own messages." ON public.messages FOR DELETE USING (auth.uid() = sender_id);

-- Friends
ALTER TABLE public.friends ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own friendships." ON public.friends FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own friendships." ON public.friends FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can delete their own friendships." ON public.friends FOR DELETE USING (auth.uid() = user_id);

-- Friend Requests
ALTER TABLE public.friend_requests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view friend requests they sent or received." ON public.friend_requests FOR SELECT USING (auth.uid() = sender_id OR auth.uid() = receiver_id);
CREATE POLICY "Users can insert their own friend requests." ON public.friend_requests FOR INSERT WITH CHECK (auth.uid() = sender_id);
CREATE POLICY "Users can update friend requests sent to them." ON public.friend_requests FOR UPDATE USING (auth.uid() = receiver_id);

-- Storage: Files
CREATE POLICY "Users can view their own folder" ON storage.objects FOR SELECT USING (bucket_id = 'files' AND owner = auth.uid());
CREATE POLICY "Users can upload to their own folder" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'files' AND owner = auth.uid());
CREATE POLICY "Users can update their own files" ON storage.objects FOR UPDATE WITH CHECK (bucket_id = 'files' AND owner = auth.uid());
CREATE POLICY "Users can delete their own files" ON storage.objects FOR DELETE USING (bucket_id = 'files' AND owner = auth.uid());
